#* @vtlvariable name="formatedFactoryName" type="java.lang.String" *#
#* @vtlvariable name="packElem" type="java.lang.String" *#
#* @vtlvariable name="ctx" type="org.kevoree.modeling.kotlin.generator.GenerationContext" *#
#* @vtlvariable name="FQNHelper" type="org.kevoree.modeling.kotlin.generator.ProcessorHelper" *#


package ${packElem}

trait ${formatedFactoryName}Impl : org.kevoree.modeling.api.KMFContainer {

    internal open var internal_eContainer : org.kevoree.modeling.api.${formatedFactoryName}?
    internal open var internal_unsetCmd : RemoveFromContainerCommand?

    override fun eContainer() : org.kevoree.modeling.api.${formatedFactoryName}? { return internal_eContainer }
    internal open var internal_containmentRefName : String?
    internal open var internal_readOnlyElem : Boolean
    internal open var internal_recursive_readOnlyElem : Boolean

    override fun setRecursiveReadOnly(){
        if(internal_recursive_readOnlyElem == true){return}
        setInternalRecursiveReadOnly()
        val recVisitor = object : org.kevoree.modeling.api.util.ModelVisitor(){
            override fun visit(elem : org.kevoree.modeling.api.KMFContainer, refNameInParent : String, parent : org.kevoree.modeling.api.KMFContainer){
                if(elem.isRecursiveReadOnly()){
                    noChildrenVisit()
                }else {
                    (elem as ${formatedFactoryName}Impl).setInternalRecursiveReadOnly()
                    elem.setInternalReadOnly()
                }
            }
        }
        visit(recVisitor,true,true,true)
        setInternalReadOnly()
    }

    override fun setInternalReadOnly(){
        internal_readOnlyElem = true
    }

    fun setInternalRecursiveReadOnly(){
        internal_recursive_readOnlyElem = true
    }

    override fun getRefInParent() : String? {
        return internal_containmentRefName
    }

    override fun isReadOnly() : Boolean {
        return internal_readOnlyElem
    }

    override fun isRecursiveReadOnly() : Boolean {
        return internal_recursive_readOnlyElem
    }

    fun internalGetKey() : String?

    fun setEContainer( container : org.kevoree.modeling.api.${formatedFactoryName}?, unsetCmd : RemoveFromContainerCommand?, refNameInParent : String? ) {

        if(internal_readOnlyElem){return}

        val tempUnsetCmd = internal_unsetCmd
        internal_unsetCmd = null
        if(tempUnsetCmd != null){
            tempUnsetCmd.run()
        }
        internal_eContainer = container
        internal_unsetCmd = unsetCmd

        internal_containmentRefName = refNameInParent

    }

#if($ctx.genSelector)

#else
    override fun selectByQuery(query : String) : List<Any> {
        throw Exception("Not activated, please add selector option in KMF generation plugin")
    }
#end


    fun createClone(_factories:${FQNHelper.fqn($ctx, $ctx.getBasePackageForUtilitiesGeneration())}.factory.MainFactory) : org.kevoree.modeling.api.KMFContainer
#if(${ctx.jS})
fun resolve(addrs : java.util.HashMap<Any,Any>,readOnly:Boolean, mutableOnly: Boolean)
#else
fun resolve(addrs : java.util.IdentityHashMap<Any,Any>,readOnly:Boolean, mutableOnly: Boolean)
#end

#if(${ctx.isGenTrace()})
    #set($tracePack=${FQNHelper.fqn($ctx, $ctx.getBasePackageForUtilitiesGeneration())})
    fun generateDiffTraces(similarObj : org.kevoree.modeling.api.KMFContainer?, inter : Boolean, ref : Boolean) : List<org.kevoree.modeling.api.trace.ModelTrace>
#end

#if($ctx.generateEvents())
    internal var internal_modelElementListeners : MutableList<org.kevoree.modeling.api.events.ModelElementListener>?

    protected fun fireModelEvent(evt : org.kevoree.modeling.api.events.ModelEvent) {
        if(internal_modelElementListeners != null) {
            for(lst in internal_modelElementListeners!!) {
                lst.elementChanged(evt)
            }
        }
        fireModelEventOnTree(evt)
    }

    override fun addModelElementListener(lst : org.kevoree.modeling.api.events.ModelElementListener){
            if(internal_modelElementListeners == null) {
                internal_modelElementListeners = java.util.ArrayList<org.kevoree.modeling.api.events.ModelElementListener>()
            }
            internal_modelElementListeners!!.add(lst)
        }

    override fun removeModelElementListener(lst : org.kevoree.modeling.api.events.ModelElementListener){
            if(internal_modelElementListeners != null) {
                internal_modelElementListeners!!.remove(lst)
                if(internal_modelElementListeners!!.isEmpty()) {
                    internal_modelElementListeners = null
                }
            }
        }

    override fun removeAllModelElementListeners() {
            if(internal_modelElementListeners != null) {
                internal_modelElementListeners!!.clear()
                internal_modelElementListeners = null
            }
        }

        internal var internal_modelTreeListeners : MutableList<org.kevoree.modeling.api.events.ModelElementListener>?

        private fun fireModelEventOnTree(evt: org.kevoree.modeling.api.events.ModelEvent) {
            if(internal_modelTreeListeners != null) {
                for(lst in internal_modelTreeListeners!!) {
                    lst.elementChanged(evt)
                }
            }
            if(eContainer() != null) {
                (eContainer() as KMFContainerImpl).fireModelEventOnTree(evt)
            }
        }

    override fun addModelTreeListener(lst : org.kevoree.modeling.api.events.ModelElementListener){
            if(internal_modelTreeListeners == null) {
                internal_modelTreeListeners = java.util.ArrayList<org.kevoree.modeling.api.events.ModelElementListener>()
            }
            internal_modelTreeListeners!!.add(lst)
        }

    override fun removeModelTreeListener(lst : org.kevoree.modeling.api.events.ModelElementListener){
            if(internal_modelTreeListeners != null) {
                internal_modelTreeListeners!!.remove(lst)
                if(internal_modelTreeListeners!!.isEmpty()) {
                    internal_modelTreeListeners = null
                }
            }
        }

    override fun removeAllModelTreeListeners() {
            if(internal_modelTreeListeners != null) {
                internal_modelTreeListeners!!.clear()
                internal_modelElementListeners = null
            }
        }

#else
    override fun addModelElementListener(lst : org.kevoree.modeling.api.events.ModelElementListener){
        throw Exception("Not activated, please add events option in KMF generation plugin")
    }
    override fun removeModelElementListener(lst : org.kevoree.modeling.api.events.ModelElementListener ){
        throw Exception("Not activated, please add events option in KMF generation plugin")
    }
    override fun removeAllModelElementListeners(){
        throw Exception("Not activated, please add events option in KMF generation plugin")
    }
    override fun addModelTreeListener(lst : org.kevoree.modeling.api.events.ModelElementListener){
        throw Exception("Not activated, please add events option in KMF generation plugin")
    }
    override fun removeModelTreeListener(lst : org.kevoree.modeling.api.events.ModelElementListener){
        throw Exception("Not activated, please add events option in KMF generation plugin")
    }
    override fun removeAllModelTreeListeners(){
        throw Exception("Not activated, please add events option in KMF generation plugin")
    }
#end

    override fun visit(visitor : org.kevoree.modeling.api.util.ModelVisitor, recursive : Boolean, containedReference : Boolean,nonContainedReference : Boolean){}
    override fun visit(visitor : org.kevoree.modeling.api.util.ModelAttributeVisitor){}

    fun internal_visit(visitor : org.kevoree.modeling.api.util.ModelVisitor,internalElem : org.kevoree.modeling.api.KMFContainer?,recursive:Boolean,containedReference : Boolean,nonContainedReference : Boolean, refName : String){
        if(internalElem != null){
            if(nonContainedReference){
                var elemPath = internalElem.path()!!
                if(visitor.alreadyVisited.containsKey(elemPath)){return}
                visitor.alreadyVisited.put(elemPath,internalElem)
            }
            visitor.visit(internalElem,refName,this)
            if(!visitor.visitStopped){
                if(recursive && visitor.visitChildren){
                    internalElem.visit(visitor,recursive,containedReference,nonContainedReference)
                }
                visitor.visitChildren = true
            }
        }
    }

}